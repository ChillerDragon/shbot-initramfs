==> jobs-run-sigchld-trap.patch <==
*** ../bash-4.3-patched/jobs.c	2014-03-28 10:54:19.000000000 -0400
--- x/jobs.c	2014-04-15 08:47:03.000000000 -0400
***************
*** 3598,3601 ****
--- 3598,3602 ----
    unwind_protect_pointer (the_pipeline);
    unwind_protect_pointer (subst_assign_varlist);
+   unwind_protect_pointer (this_shell_builtin);
  
    /* We have to add the commands this way because they will be run
==> readline-horizontal-redisplay.patch <==
*** ../bash-4.3-patched/lib/readline/display.c	2014-04-08 18:19:36.000000000 -0400
--- x/lib/readline/display.c	2014-04-20 18:32:52.000000000 -0400
***************
*** 1638,1642 ****
       the spot of first difference is before the end of the invisible chars,
       lendiff needs to be adjusted. */
!   if (current_line == 0 && !_rl_horizontal_scroll_mode &&
        current_invis_chars != visible_wrap_offset)
      {
--- 1638,1642 ----
       the spot of first difference is before the end of the invisible chars,
       lendiff needs to be adjusted. */
!   if (current_line == 0 && /* !_rl_horizontal_scroll_mode && */
        current_invis_chars != visible_wrap_offset)
      {
***************
*** 1826,1831 ****
  		_rl_last_c_pos += bytes_to_insert;
  
  	      if (_rl_horizontal_scroll_mode && ((oe-old) > (ne-new)))
! 		goto clear_rest_of_line;
  	    }
  	}
--- 1826,1836 ----
  		_rl_last_c_pos += bytes_to_insert;
  
+ 	      /* XXX - we only want to do this if we are at the end of the line
+ 		 so we move there with _rl_move_cursor_relative */
  	      if (_rl_horizontal_scroll_mode && ((oe-old) > (ne-new)))
! 		{
! 		  _rl_move_cursor_relative (ne-new, new);
! 		  goto clear_rest_of_line;
! 		}
  	    }
  	}
==> complete-dequoting.patch <==
*** ../bash-4.3-patched/bashline.c	2014-02-09 19:56:58.000000000 -0500
--- x/bashline.c	2014-04-25 14:57:52.000000000 -0400
***************
*** 4168,4174 ****
  
    qc = rl_dispatching ? rl_completion_quote_character : 0;  
!   dfn = bash_dequote_filename ((char *)text, qc);
    m1 = rl_completion_matches (dfn, rl_filename_completion_function);
!   free (dfn);
  
    if (m1 == 0 || m1[0] == 0)
--- 4209,4222 ----
  
    qc = rl_dispatching ? rl_completion_quote_character : 0;  
!   /* If rl_completion_found_quote != 0, rl_completion_matches will call the
!      filename dequoting function, causing the directory name to be dequoted
!      twice. */
!   if (rl_dispatching && rl_completion_found_quote == 0)
!     dfn = bash_dequote_filename ((char *)text, qc);
!   else
!     dfn = (char *)text;
    m1 = rl_completion_matches (dfn, rl_filename_completion_function);
!   if (dfn != text)
!     free (dfn);
  
    if (m1 == 0 || m1[0] == 0)
==> extglob-directory.patch <==
*** ../bash-4.3-patched/lib/glob/glob.c	2014-03-28 10:54:23.000000000 -0400
--- x/lib/glob/glob.c	2014-05-02 10:24:28.000000000 -0400
***************
*** 124,127 ****
--- 124,129 ----
  extern wchar_t *glob_patscan_wc __P((wchar_t *, wchar_t *, int));
  
+ extern char *glob_dirscan __P((char *, int));
+ 
  /* Compile `glob_loop.c' for single-byte characters. */
  #define CHAR	unsigned char
***************
*** 188,191 ****
--- 190,196 ----
    pe = glob_patscan (pp, se, 0);	/* end of extglob pattern (( */
    /* we should check for invalid extglob pattern here */
+   if (pe == 0)
+     return 0;
+ 
    /* if pe != se we have more of the pattern at the end of the extglob
       pattern. Check the easy case first ( */
***************
*** 1016,1020 ****
    char **result;
    unsigned int result_size;
!   char *directory_name, *filename, *dname;
    unsigned int directory_len;
    int free_dirname;			/* flag */
--- 1021,1025 ----
    char **result;
    unsigned int result_size;
!   char *directory_name, *filename, *dname, *fn;
    unsigned int directory_len;
    int free_dirname;			/* flag */
***************
*** 1032,1035 ****
--- 1037,1052 ----
    /* Find the filename.  */
    filename = strrchr (pathname, '/');
+ #if defined (EXTENDED_GLOB)
+   if (filename && extended_glob)
+     {
+       fn = glob_dirscan (pathname, '/');
+ #if DEBUG_MATCHING
+       if (fn != filename)
+ 	fprintf (stderr, "glob_filename: glob_dirscan: fn (%s) != filename (%s)\n", fn ? fn : "(null)", filename);
+ #endif
+       filename = fn;
+     }
+ #endif
+ 
    if (filename == NULL)
      {
*** ../bash-4.3-patched/lib/glob/gmisc.c	2014-03-28 10:54:23.000000000 -0400
--- x/lib/glob/gmisc.c	2014-05-02 09:35:57.000000000 -0400
***************
*** 43,46 ****
--- 43,48 ----
  #define WRPAREN         L')'
  
+ extern char *glob_patscan __P((char *, char *, int));
+ 
  /* Return 1 of the first character of WSTRING could match the first
     character of pattern WPAT.  Wide character version. */
***************
*** 376,377 ****
--- 378,410 ----
    return matlen;
  }
+ 
+ /* Skip characters in PAT and return the final occurrence of DIRSEP.  This
+    is only called when extended_glob is set, so we have to skip over extglob
+    patterns x(...) */
+ char *
+ glob_dirscan (pat, dirsep)
+      char *pat;
+      int dirsep;
+ {
+   char *p, *d, *pe, *se;
+ 
+   d = pe = se = 0;
+   for (p = pat; p && *p; p++)
+     {
+       if (extglob_pattern_p (p))
+ 	{
+ 	  if (se == 0)
+ 	    se = p + strlen (p) - 1;
+ 	  pe = glob_patscan (p + 2, se, 0);
+ 	  if (pe == 0)
+ 	    continue;
+ 	  else if (*pe == 0)
+ 	    break;
+ 	  p = pe - 1;	/* will do increment above */
+ 	  continue;
+ 	}
+       if (*p ==  dirsep)
+ 	d = p;
+     }
+   return d;
+ }
