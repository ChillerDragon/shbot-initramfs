#!/bin/sh
patch -p1 << 'EOF'
diff --git a/arrayfunc.c b/arrayfunc.c
index 3bdd54f..76116bc 100644
--- a/arrayfunc.c
+++ b/arrayfunc.c
@@ -592,11 +592,7 @@ array_expand_index (s, len)
   exp = (char *)xmalloc (len);
   strncpy (exp, s, len - 1);
   exp[len - 1] = '\0';
-#if 0
-  t = expand_string_to_string (exp, 0);
-#else 
-  t = expand_string_to_string (exp, Q_DOUBLE_QUOTES);
-#endif
+  t = expand_arith_string (exp, 0);
   this_command_name = (char *)NULL;
   val = evalexp (t, &expok);
   free (t);
diff --git a/doc/bash.1 b/doc/bash.1
index 40e1fbd..c56da76 100644
--- a/doc/bash.1
+++ b/doc/bash.1
@@ -6,12 +6,12 @@
 .\"	Case Western Reserve University
 .\"	chet@po.cwru.edu
 .\"
-.\"	Last Change: Sat Aug 27 13:28:44 EDT 2005
+.\"	Last Change: Wed Dec 28 19:58:45 EST 2005
 .\"
 .\" bash_builtins, strip all but Built-Ins section
 .if \n(zZ=1 .ig zZ
 .if \n(zY=1 .ig zY
-.TH BASH 1 "2005 Aug 27" "GNU Bash-3.1-beta1"
+.TH BASH 1 "2005 Dec 28" "GNU Bash-3.1"
 .\"
 .\" There's some problem with having a `@'
 .\" in a tagged paragraph with the BSD man macros.
@@ -677,8 +677,8 @@ If the shell option
 .B nocasematch
 is enabled, the match is performed without regard to the case
 of alphabetic characters.
-The return value is 0 if the string matches or does not match
-the pattern, respectively, and 1 otherwise.
+The return value is 0 if the string matches (\fB==\fP) or does not match
+(\fB!=\fP) the pattern, and 1 otherwise.
 Any part of the pattern may be quoted to force it to be matched as a
 string.
 .if t .sp 0.5
@@ -807,6 +807,12 @@ it against each \fIpattern\fP in turn, using the same matching rules
 as for pathname expansion (see
 .B Pathname Expansion
 below).
+The \fIword\fP is expanded using tilde
+expansion, parameter and variable expansion, arithmetic substituion,
+command substitution, process substitution and quote removal.
+Each \fIpattern\fP examined is expanded using tilde
+expansion, parameter and variable expansion, arithmetic substituion,
+command substitution, and process substitution.
 If the shell option
 .B nocasematch
 is enabled, the match is performed without regard to the case
@@ -8484,7 +8490,7 @@ option suppresses shell function lookup, as with the \fBcommand\fP builtin.
 returns true if any of the arguments are found, false if
 none are found.
 .TP
-\fBulimit\fP [\fB\-SHacdflmnpstuv\fP [\fIlimit\fP]]
+\fBulimit\fP [\fB\-SHacdfilmnpqstuvx\fP [\fIlimit\fP]]
 Provides control over the resources available to the shell and to
 processes started by it, on systems that allow such control.
 The \fB\-H\fP and \fB\-S\fP options specify that the hard or soft limit is
@@ -8523,6 +8529,9 @@ The maximum size of a process's data segment
 .B \-f
 The maximum size of files created by the shell
 .TP
+.B \-i
+The maximum number of pending signals
+.TP
 .B \-l
 The maximum size that may be locked into memory
 .TP
@@ -8536,6 +8545,9 @@ allow this value to be set)
 .B \-p
 The pipe size in 512-byte blocks (this may not be set)
 .TP
+.B \-q
+The maximum number of bytes in POSIX message queues
+.TP
 .B \-s
 The maximum stack size
 .TP
@@ -8547,6 +8559,9 @@ The maximum number of processes available to a single user
 .TP
 .B \-v
 The maximum amount of virtual memory available to the shell
+.TP
+.B \-x
+The maximum number of file locks
 .PD
 .PP
 If
diff --git a/doc/bashref.texi b/doc/bashref.texi
index b25dad9..75da46b 100644
--- a/doc/bashref.texi
+++ b/doc/bashref.texi
@@ -961,8 +961,8 @@ If the shell option @code{nocasematch}
 (see the description of @code{shopt} in @ref{Bash Builtins})
 is enabled, the match is performed without regard to the case
 of alphabetic characters.
-The return value is 0 if the string matches or does not match
-the pattern, respectively, and 1 otherwise.
+The return value is 0 if the string matches (@samp{==}) or does not
+match (@samp{!=})the pattern, and 1 otherwise.
 Any part of the pattern may be quoted to force it to be matched as a
 string.
 
@@ -2598,7 +2598,7 @@ the command directly, without invoking another program.
 Builtin commands are necessary to implement functionality impossible
 or inconvenient to obtain with separate utilities.
 
-This section briefly the builtins which Bash inherits from
+This section briefly describes the builtins which Bash inherits from
 the Bourne Shell, as well as the builtin commands which are unique
 to or have been extended in Bash.
 
@@ -3833,7 +3833,7 @@ builtin command.
 @item ulimit
 @btindex ulimit
 @example
-ulimit [-acdflmnpstuvSH] [@var{limit}]
+ulimit [-acdfilmnpqstuvxSH] [@var{limit}]
 @end example
 @code{ulimit} provides control over the resources available to processes
 started by the shell, on systems that allow such control.  If an
@@ -3857,6 +3857,9 @@ The maximum size of a process's data segment.
 @item -f
 The maximum size of files created by the shell.
 
+@item -i
+The maximum number of pending signals.
+
 @item -l
 The maximum size that may be locked into memory.
 
@@ -3869,6 +3872,9 @@ The maximum number of open file descriptors.
 @item -p
 The pipe buffer size.
 
+@item -q
+The maximum number of bytes in POSIX message queues.
+
 @item -s
 The maximum stack size.
 
@@ -3881,6 +3887,9 @@ The maximum number of processes available to a single user.
 @item -v
 The maximum amount of virtual memory available to the process.
 
+@item -x
+The maximum number of file locks.
+
 @end table
 
 If @var{limit} is given, it is the new value of the specified resource;
@@ -4089,8 +4098,8 @@ shell will exit.
 Print shell input lines as they are read.
 
 @item -x
-Print a trace of simple commands, \fBfor\fP commands, \fBcase\fP
-commands, \fBselect\fP commands, and arithmetic \fBfor\fP commands
+Print a trace of simple commands, @code{for} commands, @code{case}
+commands, @code{select} commands, and arithmetic @code{for} commands
 and their arguments or associated word lists after they are
 expanded and before they are executed.  The value of the @env{PS4}
 variable is expanded and the resultant value is printed before
diff --git a/doc/version.texi b/doc/version.texi
index f769a19..6ee00d4 100644
--- a/doc/version.texi
+++ b/doc/version.texi
@@ -2,9 +2,9 @@
 Copyright (C) 1988-2005 Free Software Foundation, Inc.
 @end ignore
 
-@set LASTCHANGE Mon Sep  5 11:47:04 EDT 2005
+@set LASTCHANGE Fri Dec 30 10:50:51 EST 2005
 
-@set EDITION 3.1-beta1
-@set VERSION 3.1-beta1
-@set UPDATED 5 September 2005
-@set UPDATED-MONTH September 2005
+@set EDITION 3.1
+@set VERSION 3.1
+@set UPDATED 30 December 2005
+@set UPDATED-MONTH December 2005
diff --git a/jobs.c b/jobs.c
index 0671c65..d30a427 100644
--- a/jobs.c
+++ b/jobs.c
@@ -619,8 +619,11 @@ stop_pipeline (async, deferred)
 	   * once in the parent and once in each child.  This is where
 	   * the parent gives it away.
 	   *
+	   * Don't give the terminal away if this shell is an asynchronous
+	   * subshell.
+	   *
 	   */
-	  if (job_control && newjob->pgrp)
+	  if (job_control && newjob->pgrp && (subshell_environment&SUBSHELL_ASYNC) == 0)
 	    give_terminal_to (newjob->pgrp, 0);
 	}
     }
@@ -844,9 +847,10 @@ static void
 realloc_jobs_list ()
 {
   sigset_t set, oset;
-  int nsize, i, j;
+  int nsize, i, j, ncur, nprev;
   JOB **nlist;
 
+  ncur = nprev = NO_JOB;
   nsize = ((js.j_njobs + JOB_SLOTS - 1) / JOB_SLOTS);
   nsize *= JOB_SLOTS;
   i = js.j_njobs % JOB_SLOTS;
@@ -854,17 +858,51 @@ realloc_jobs_list ()
     nsize += JOB_SLOTS;
 
   BLOCK_CHILD (set, oset);
-  nlist = (JOB **) xmalloc (nsize * sizeof (JOB *));
+  nlist = (js.j_jobslots == nsize) ? jobs : (JOB **) xmalloc (nsize * sizeof (JOB *));
+
   for (i = j = 0; i < js.j_jobslots; i++)
     if (jobs[i])
-      nlist[j++] = jobs[i];
+      {
+	if (i == js.j_current)
+	  ncur = j;
+	if (i == js.j_previous)
+	  nprev = j;
+	nlist[j++] = jobs[i];
+      }
+
+#if defined (DEBUG)
+  itrace ("realloc_jobs_list: resize jobs list from %d to %d", js.j_jobslots, nsize);
+  itrace ("realloc_jobs_list: j_lastj changed from %d to %d", js.j_lastj, (j > 0) ? j - 1 : 0);
+  itrace ("realloc_jobs_list: j_njobs changed from %d to %d", js.j_njobs, (j > 0) ? j - 1 : 0);
+#endif
 
   js.j_firstj = 0;
-  js.j_lastj = (j > 0) ? j - 1: 0;
+  js.j_lastj = (j > 0) ? j - 1 : 0;
+  js.j_njobs = j;
   js.j_jobslots = nsize;
 
-  free (jobs);
-  jobs = nlist;
+  /* Zero out remaining slots in new jobs list */
+  for ( ; j < nsize; j++)
+    nlist[j] = (JOB *)NULL;
+
+  if (jobs != nlist)
+    {
+      free (jobs);
+      jobs = nlist;
+    }
+
+  if (ncur != NO_JOB)
+    js.j_current = ncur;
+  if (nprev != NO_JOB)
+    js.j_previous = nprev;
+
+  /* Need to reset these */
+  if (js.j_current == NO_JOB || js.j_previous == NO_JOB || js.j_current > js.j_lastj || js.j_previous > js.j_lastj)
+    reset_current ();
+
+#ifdef DEBUG
+  itrace ("realloc_jobs_list: reset js.j_current (%d) and js.j_previous (%d)", js.j_current, js.j_previous);
+#endif
 
   UNBLOCK_CHILD (oset);
 }
@@ -1655,7 +1693,7 @@ make_child (command, async_p)
 	     In this case, we don't want to give the terminal to the
 	     shell's process group (we could be in the middle of a
 	     pipeline, for example). */
-	  if (async_p == 0 && pipeline_pgrp != shell_pgrp)
+	  if (async_p == 0 && pipeline_pgrp != shell_pgrp && ((subshell_environment&SUBSHELL_ASYNC) == 0))
 	    give_terminal_to (pipeline_pgrp, 0);
 
 #if defined (PGRP_PIPE)
@@ -2198,7 +2236,11 @@ wait_for (pid)
   /* This is possibly a race condition -- should it go in stop_pipeline? */
   wait_sigint_received = 0;
   if (job_control == 0)
-    old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);
+    {
+      old_sigint_handler = set_signal_handler (SIGINT, wait_sigint_handler);
+      if (old_sigint_handler == SIG_IGN)
+	set_signal_handler (SIGINT, old_sigint_handler);
+    }
 
   termination_state = last_command_exit_value;
 
diff --git a/lib/glob/glob.c b/lib/glob/glob.c
index 9a2d833..1453b06 100644
--- a/lib/glob/glob.c
+++ b/lib/glob/glob.c
@@ -360,6 +360,7 @@ glob_vector (pat, dir, flags)
   count = lose = skip = 0;
 
   firstmalloc = 0;
+  nalloca = 0;
 
   /* If PAT is empty, skip the loop, but return one (empty) filename. */
   if (pat == 0 || *pat == '\0')
@@ -546,6 +547,8 @@ glob_vector (pat, dir, flags)
 		firstmalloc = 0;
 	      tmplink = lastlink;
 	    }
+	  else
+	    tmplink = 0;
 	  free (lastlink->name);
 	  lastlink = lastlink->next;
 	  FREE (tmplink);
diff --git a/lib/glob/sm_loop.c b/lib/glob/sm_loop.c
index 6e8cf3a..d66ad18 100644
--- a/lib/glob/sm_loop.c
+++ b/lib/glob/sm_loop.c
@@ -638,12 +638,13 @@ EXTMATCH (xc, s, se, p, pe, flags)
   CHAR *psub;			/* pointer to sub-pattern */
   CHAR *pnext;			/* pointer to next sub-pattern */
   CHAR *srest;			/* pointer to rest of string */
-  int m1, m2;
+  int m1, m2, xflags;		/* xflags = flags passed to recursive matches */
 
 #if DEBUG_MATCHING
 fprintf(stderr, "extmatch: xc = %c\n", xc);
 fprintf(stderr, "extmatch: s = %s; se = %s\n", s, se);
 fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
+fprintf(stderr, "extmatch: flags = %d\n", flags);
 #endif
 
   prest = PATSCAN (p + (*p == L('(')), pe, 0); /* ) */
@@ -677,8 +678,12 @@ fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
 		 string matches the rest of the pattern.  Also handle
 		 multiple matches of the pattern. */
 	      if (m1)
-		m2 = (GMATCH (srest, se, prest, pe, flags) == 0) ||
-		      (s != srest && GMATCH (srest, se, p - 1, pe, flags) == 0);
+		{
+		  /* if srest > s, we are not at start of string */
+		  xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;
+		  m2 = (GMATCH (srest, se, prest, pe, xflags) == 0) ||
+			(s != srest && GMATCH (srest, se, p - 1, pe, xflags) == 0);
+		}
 	      if (m1 && m2)
 		return (0);
 	    }
@@ -704,8 +709,10 @@ fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
 	  srest = (prest == pe) ? se : s;
 	  for ( ; srest <= se; srest++)
 	    {
+	      /* if srest > s, we are not at start of string */
+	      xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;
 	      if (GMATCH (s, srest, psub, pnext - 1, flags) == 0 &&
-		  GMATCH (srest, se, prest, pe, flags) == 0)
+		  GMATCH (srest, se, prest, pe, xflags) == 0)
 		return (0);
 	    }
 	  if (pnext == prest)
@@ -726,7 +733,9 @@ fprintf(stderr, "extmatch: p = %s; pe = %s\n", p, pe);
 	      if (pnext == prest)
 		break;
 	    }
-	  if (m1 == 0 && GMATCH (srest, se, prest, pe, flags) == 0)
+	  /* if srest > s, we are not at start of string */
+	  xflags = (srest > s) ? (flags & ~FNM_PERIOD) : flags;
+	  if (m1 == 0 && GMATCH (srest, se, prest, pe, xflags) == 0)
 	    return (0);
 	}
       return (FNM_NOMATCH);
diff --git a/lib/readline/display.c b/lib/readline/display.c
index b22521b..0d3ae6e 100644
--- a/lib/readline/display.c
+++ b/lib/readline/display.c
@@ -1983,11 +1983,15 @@ _rl_make_prompt_for_search (pchar)
      int pchar;
 {
   int len;
-  char *pmt;
+  char *pmt, *p;
 
   rl_save_prompt ();
 
-  if (saved_local_prompt == 0)
+  /* We've saved the prompt, and can do anything with the various prompt
+     strings we need before they're restored.  We want the unexpanded
+     portion of the prompt string after any final newline. */
+  p = rl_prompt ? strrchr (rl_prompt, '\n') : 0;
+  if (p == 0)
     {
       len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
       pmt = (char *)xmalloc (len + 2);
@@ -1998,19 +2002,17 @@ _rl_make_prompt_for_search (pchar)
     }
   else
     {
-      len = *saved_local_prompt ? strlen (saved_local_prompt) : 0;
+      p++;
+      len = strlen (p);
       pmt = (char *)xmalloc (len + 2);
       if (len)
-	strcpy (pmt, saved_local_prompt);
+	strcpy (pmt, p);
       pmt[len] = pchar;
       pmt[len+1] = '\0';
-      local_prompt = savestring (pmt);
-      prompt_last_invisible = saved_last_invisible;
-      prompt_visible_length = saved_visible_length + 1;
-    }
+    }  
 
+  /* will be overwritten by expand_prompt, called from rl_message */
   prompt_physical_chars = saved_physical_chars + 1;
-
   return pmt;
 }
 
diff --git a/lib/readline/readline.c b/lib/readline/readline.c
index 5e9767a..4cbd0d6 100644
--- a/lib/readline/readline.c
+++ b/lib/readline/readline.c
@@ -282,6 +282,7 @@ rl_set_prompt (prompt)
 {
   FREE (rl_prompt);
   rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
+  rl_display_prompt = rl_prompt ? rl_prompt : "";
 
   rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
   return 0;
diff --git a/lib/readline/terminal.c b/lib/readline/terminal.c
index cc61388..eb72c19 100644
--- a/lib/readline/terminal.c
+++ b/lib/readline/terminal.c
@@ -122,7 +122,7 @@ char *_rl_term_up;
 static char *_rl_visible_bell;
 
 /* Non-zero means the terminal can auto-wrap lines. */
-int _rl_term_autowrap;
+int _rl_term_autowrap = -1;
 
 /* Non-zero means that this terminal has a meta key. */
 static int term_has_meta;
@@ -274,6 +274,9 @@ void
 _rl_set_screen_size (rows, cols)
      int rows, cols;
 {
+  if (_rl_term_autowrap == -1)
+    _rl_init_terminal_io (rl_terminal_name);
+
   if (rows > 0)
     _rl_screenheight = rows;
   if (cols > 0)
diff --git a/parse.y b/parse.y
index 1e7bd27..f415df9 100644
--- a/parse.y
+++ b/parse.y
@@ -2716,6 +2716,7 @@ read_token (command)
 #define P_ALLOWESC	0x02
 #define P_DQUOTE	0x04
 #define P_COMMAND	0x08	/* parsing a command, so look for comments */
+#define P_BACKQUOTE	0x10	/* parsing a backquoted command substitution */
 
 static char matched_pair_error;
 static char *
@@ -2725,12 +2726,12 @@ parse_matched_pair (qc, open, close, lenp, flags)
      int *lenp, flags;
 {
   int count, ch, was_dollar, in_comment, check_comment;
-  int pass_next_character, nestlen, ttranslen, start_lineno;
+  int pass_next_character, backq_backslash, nestlen, ttranslen, start_lineno;
   char *ret, *nestret, *ttrans;
   int retind, retsize, rflags;
 
   count = 1;
-  pass_next_character = was_dollar = in_comment = 0;
+  pass_next_character = backq_backslash = was_dollar = in_comment = 0;
   check_comment = (flags & P_COMMAND) && qc != '\'' && qc != '"' && (flags & P_DQUOTE) == 0;
 
   /* RFLAGS is the set of flags we want to pass to recursive calls. */
@@ -2742,11 +2743,8 @@ parse_matched_pair (qc, open, close, lenp, flags)
   start_lineno = line_number;
   while (count)
     {
-#if 0
-      ch = shell_getc ((qc != '\'' || (flags & P_ALLOWESC)) && pass_next_character == 0);
-#else
-      ch = shell_getc (qc != '\'' && pass_next_character == 0);
-#endif
+      ch = shell_getc (qc != '\'' && pass_next_character == 0 && backq_backslash == 0);
+
       if (ch == EOF)
 	{
 	  free (ret);
@@ -2771,9 +2769,16 @@ parse_matched_pair (qc, open, close, lenp, flags)
 	  continue;
 	}
       /* Not exactly right yet */
-      else if (check_comment && in_comment == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || whitespace (ret[retind -1])))
+      else if MBTEST(check_comment && in_comment == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || whitespace (ret[retind - 1])))
 	in_comment = 1;
 
+      /* last char was backslash inside backquoted command substitution */
+      if (backq_backslash)
+	{
+	  backq_backslash = 0;
+	  /* Placeholder for adding special characters */
+	}
+
       if (pass_next_character)		/* last char was backslash */
 	{
 	  pass_next_character = 0;
@@ -2814,6 +2819,8 @@ parse_matched_pair (qc, open, close, lenp, flags)
 	{
 	  if MBTEST((flags & P_ALLOWESC) && ch == '\\')
 	    pass_next_character++;
+	  else if MBTEST((flags & P_BACKQUOTE) && ch == '\\')
+	    backq_backslash++;
 	  continue;
 	}
 
@@ -2898,7 +2905,11 @@ add_nestret:
 	}
       else if MBTEST(qc == '`' && (ch == '"' || ch == '\'') && in_comment == 0)
 	{
-	  nestret = parse_matched_pair (0, ch, ch, &nestlen, rflags);
+	  /* Add P_BACKQUOTE so backslash quotes the next character and
+	     shell_getc does the right thing with \<newline>.  We do this for
+	     a measure  of backwards compatibility -- it's not strictly the
+	     right POSIX thing. */
+	  nestret = parse_matched_pair (0, ch, ch, &nestlen, rflags|P_BACKQUOTE);
 	  goto add_nestret;
 	}
       else if MBTEST(was_dollar && (ch == '(' || ch == '{' || ch == '['))	/* ) } ] */
@@ -2907,7 +2918,7 @@ add_nestret:
 	  if (open == ch)	/* undo previous increment */
 	    count--;
 	  if (ch == '(')		/* ) */
-	    nestret = parse_matched_pair (0, '(', ')', &nestlen, rflags);
+	    nestret = parse_matched_pair (0, '(', ')', &nestlen, rflags & ~P_DQUOTE);
 	  else if (ch == '{')		/* } */
 	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|rflags);
 	  else if (ch == '[')		/* ] */
@@ -3578,7 +3589,7 @@ read_token_word (character)
 	      FREE (ttok);
 	      all_digit_token = 0;
 	      compound_assignment = 1;
-#if 0
+#if 1
 	      goto next_character;
 #else
 	      goto got_token;		/* ksh93 seems to do this */
@@ -3695,7 +3706,9 @@ got_token:
       struct builtin *b;
       b = builtin_address_internal (token, 0);
       if (b && (b->flags & ASSIGNMENT_BUILTIN))
-        parser_state |= PST_ASSIGNOK;
+	parser_state |= PST_ASSIGNOK;
+      else if (STREQ (token, "eval") || STREQ (token, "let"))
+	parser_state |= PST_ASSIGNOK;
     }
 
   yylval.word = the_word;
@@ -4686,18 +4699,21 @@ parse_compound_assignment (retlenp)
      int *retlenp;
 {
   WORD_LIST *wl, *rl;
-  int tok, orig_line_number, orig_token_size;
+  int tok, orig_line_number, orig_token_size, orig_last_token, assignok;
   char *saved_token, *ret;
 
   saved_token = token;
   orig_token_size = token_buffer_size;
   orig_line_number = line_number;
+  orig_last_token = last_read_token;
 
   last_read_token = WORD;	/* WORD to allow reserved words here */
 
   token = (char *)NULL;
   token_buffer_size = 0;
 
+  assignok = parser_state&PST_ASSIGNOK;		/* XXX */
+
   wl = (WORD_LIST *)NULL;	/* ( */
   parser_state |= PST_COMPASSIGN;
 
@@ -4740,7 +4756,7 @@ parse_compound_assignment (retlenp)
 	jump_to_top_level (DISCARD);
     }
 
-  last_read_token = WORD;
+  last_read_token = orig_last_token;		/* XXX - was WORD? */
   if (wl)
     {
       rl = REVERSE_LIST (wl, WORD_LIST *);
@@ -4752,6 +4768,10 @@ parse_compound_assignment (retlenp)
 
   if (retlenp)
     *retlenp = (ret && *ret) ? strlen (ret) : 0;
+
+  if (assignok)
+    parser_state |= PST_ASSIGNOK;
+
   return ret;
 }
 
diff --git a/patchlevel.h b/patchlevel.h
index b11fc16..e8ce389 100644
--- a/patchlevel.h
+++ b/patchlevel.h
@@ -25,6 +25,6 @@
    regexp `^#define[ 	]*PATCHLEVEL', since that's what support/mkversion.sh
    looks for to find the patch level (for the sccs version string). */
 
-#define PATCHLEVEL 0
+#define PATCHLEVEL 17
 
 #endif /* _PATCHLEVEL_H_ */
diff --git a/subst.c b/subst.c
index 73887ab..bf91fee 100644
--- a/subst.c
+++ b/subst.c
@@ -2187,7 +2187,7 @@ do_compound_assignment (name, value, flags)
   if (mklocal && variable_context)
     {
       v = find_variable (name);
-      if (v == 0 || array_p (v) == 0)
+      if (v == 0 || array_p (v) == 0 || v->context != variable_context)
         v = make_local_array_variable (name);
       v = assign_array_var_from_string (v, value, flags);
     }
@@ -2575,6 +2575,13 @@ expand_assignment_string_to_string (string, quoted)
   return (expand_string_to_string_internal (string, quoted, expand_string_assignment));
 }
 
+char *
+expand_arith_string (string, quoted)
+     char *string;
+{
+  return (expand_string_if_necessary (string, quoted, expand_string));
+}
+
 #if defined (COND_COMMAND)
 /* Just remove backslashes in STRING.  Returns a new string. */
 char *
@@ -5248,7 +5255,7 @@ verify_substring_values (value, substr, vtype, e1p, e2p)
   else
     t = (char *)0;
 
-  temp1 = expand_string_if_necessary (substr, Q_DOUBLE_QUOTES, expand_string);
+  temp1 = expand_arith_string (substr, Q_DOUBLE_QUOTES);
   *e1p = evalexp (temp1, &expok);
   free (temp1);
   if (expok == 0)
@@ -5293,7 +5300,7 @@ verify_substring_values (value, substr, vtype, e1p, e2p)
     {
       t++;
       temp2 = savestring (t);
-      temp1 = expand_string_if_necessary (temp2, Q_DOUBLE_QUOTES, expand_string);
+      temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
       free (temp2);
       t[-1] = ':';
       *e2p = evalexp (temp1, &expok);
@@ -6435,7 +6442,7 @@ param_expand (string, sindex, quoted, expanded_something,
 	  temp2[t_index] = '\0';
 
 	  /* Expand variables found inside the expression. */
-	  temp1 = expand_string_if_necessary (temp2, Q_DOUBLE_QUOTES, expand_string);
+	  temp1 = expand_arith_string (temp2, Q_DOUBLE_QUOTES);
 	  free (temp2);
 
 arithsub:
@@ -6477,7 +6484,7 @@ comsub:
       zindex = t_index;
 
        /* Do initial variable expansion. */
-      temp1 = expand_string_if_necessary (temp, Q_DOUBLE_QUOTES, expand_string);
+      temp1 = expand_arith_string (temp, Q_DOUBLE_QUOTES);
 
       goto arithsub;
 
@@ -6795,6 +6802,12 @@ add_string:
 	  if (temp && *temp && t_index > 0)
 	    {
 	      temp1 = bash_tilde_expand (temp, tflag);
+	      if  (temp1 && *temp1 == '~' && STREQ (temp, temp1))
+		{
+		  FREE (temp);
+		  FREE (temp1);
+		  goto add_character;		/* tilde expansion failed */
+		}
 	      free (temp);
 	      temp = temp1;
 	      sindex += t_index;
diff --git a/subst.h b/subst.h
index 33d3f49..e07055b 100644
--- a/subst.h
+++ b/subst.h
@@ -151,6 +151,9 @@ extern char *expand_string_to_string __P((char *, int));
 extern char *expand_string_unsplit_to_string __P((char *, int));
 extern char *expand_assignment_string_to_string __P((char *, int));
 
+/* Expand an arithmetic expression string */
+extern char *expand_arith_string __P((char *, int));
+
 /* De-quoted quoted characters in STRING. */
 extern char *dequote_string __P((char *));
 
diff --git a/variables.c b/variables.c
index 62e2604..7772012 100644
--- a/variables.c
+++ b/variables.c
@@ -860,9 +860,11 @@ sh_set_lines_and_columns (lines, cols)
 {
   char val[INT_STRLEN_BOUND(int) + 1], *v;
 
+#if defined (READLINE)
   /* If we are currently assigning to LINES or COLUMNS, don't do anything. */
   if (winsize_assignment)
     return;
+#endif
 
   v = inttostr (lines, val, sizeof (val));
   bind_variable ("LINES", v, 0);
EOF
patch -p0 <<'EOF'
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-018

Bug-Reported-by:	Stephane Chazelas <stephane.chazelas@gmail.com>
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

Under certain circumstances, bash will execute user code while processing the
environment for exported function definitions.

Patch:

*** ../bash-3.1.17/builtins/common.h	2004-09-09 13:21:08.000000000 -0400
--- builtins/common.h	2014-09-16 22:00:02.000000000 -0400
***************
*** 34,37 ****
--- 34,39 ----
  
  /* Flags for describe_command, shared between type.def and command.def */
+ #define SEVAL_FUNCDEF	0x080		/* only allow function definitions */
+ #define SEVAL_ONECMD	0x100		/* only allow a single command */
  #define CDESC_ALL		0x001	/* type -a */
  #define CDESC_SHORTDESC		0x002	/* command -V */
*** ../bash-3.1.17/builtins/evalstring.c	2005-10-30 18:28:24.000000000 -0500
--- builtins/evalstring.c	2014-09-16 22:00:02.000000000 -0400
***************
*** 224,227 ****
--- 224,235 ----
  	      struct fd_bitmap *bitmap;
  
+ 	      if ((flags & SEVAL_FUNCDEF) && command->type != cm_function_def)
+ 		{
+ 		  internal_warning ("%s: ignoring function definition attempt", from_file);
+ 		  should_jump_to_top_level = 0;
+ 		  last_result = last_command_exit_value = EX_BADUSAGE;
+ 		  break;
+ 		}
+ 
  	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
  	      begin_unwind_frame ("pe_dispose");
***************
*** 279,282 ****
--- 287,293 ----
  	      dispose_fd_bitmap (bitmap);
  	      discard_unwind_frame ("pe_dispose");
+ 
+ 	      if (flags & SEVAL_ONECMD)
+ 		break;
  	    }
  	}
*** ../bash-3.1.17/variables.c	2006-03-10 16:56:29.000000000 -0500
--- variables.c	2014-09-16 22:00:02.000000000 -0400
***************
*** 311,320 ****
  	  strcpy (temp_string + char_index + 1, string);
  
! 	  parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST);
! 
! 	  /* Ancient backwards compatibility.  Old versions of bash exported
! 	     functions like name()=() {...} */
! 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '(')
! 	    name[char_index - 2] = '\0';
  
  	  if (temp_var = find_function (name))
--- 311,318 ----
  	  strcpy (temp_string + char_index + 1, string);
  
! 	  /* Don't import function names that are invalid identifiers from the
! 	     environment. */
! 	  if (legal_identifier (name))
! 	    parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
  
  	  if (temp_var = find_function (name))
***************
*** 325,332 ****
  	  else
  	    report_error (_("error importing function definition for `%s'"), name);
- 
- 	  /* ( */
- 	  if (name[char_index - 1] == ')' && name[char_index - 2] == '\0')
- 	    name[char_index - 2] = '(';		/* ) */
  	}
  #if defined (ARRAY_VARS)
--- 323,326 ----
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 17
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 18
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-019

Bug-Reported-by:	Tavis Ormandy <taviso@cmpxchg8b.com>
Bug-Reference-ID:
Bug-Reference-URL:	http://twitter.com/taviso/statuses/514887394294652929

Bug-Description:

Under certain circumstances, bash can incorrectly save a lookahead character and
return it on a subsequent call, even when reading a new line.

Patch:

*** ../bash-3.1.18/parse.y	2006-04-12 08:40:35.000000000 -0400
--- parse.y	2014-09-25 16:40:46.000000000 -0400
***************
*** 2501,2504 ****
--- 2501,2506 ----
    word_desc_to_read = (WORD_DESC *)NULL;
  
+   eol_ungetc_lookahead = 0;
+ 
    last_read_token = '\n';
    token_to_read = '\n';
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 18
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 19
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-020

Bug-Reported-by:	Florian Weimer <fweimer@redhat.com>
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

This patch changes the encoding bash uses for exported functions to avoid
clashes with shell variables and to avoid depending only on an environment
variable's contents to determine whether or not to interpret it as a shell
function.

Patch:

*** ../bash-3.1.19/variables.c	2014-09-16 22:00:02.000000000 -0400
--- variables.c	2014-09-27 21:02:50.000000000 -0400
***************
*** 75,78 ****
--- 75,83 ----
  #define ifsname(s)	((s)[0] == 'I' && (s)[1] == 'F' && (s)[2] == 'S' && (s)[3] == '\0')
  
+ #define BASHFUNC_PREFIX		"BASH_FUNC_"
+ #define BASHFUNC_PREFLEN	10	/* == strlen(BASHFUNC_PREFIX */
+ #define BASHFUNC_SUFFIX		"%%"
+ #define BASHFUNC_SUFFLEN	2	/* == strlen(BASHFUNC_SUFFIX) */
+ 
  extern char **environ;
  
***************
*** 240,244 ****
  static void dispose_temporary_env __P((sh_free_func_t *));     
  
! static inline char *mk_env_string __P((const char *, const char *));
  static char **make_env_array_from_var_list __P((SHELL_VAR **));
  static char **make_var_export_array __P((VAR_CONTEXT *));
--- 245,249 ----
  static void dispose_temporary_env __P((sh_free_func_t *));     
  
! static inline char *mk_env_string __P((const char *, const char *, int));
  static char **make_env_array_from_var_list __P((SHELL_VAR **));
  static char **make_var_export_array __P((VAR_CONTEXT *));
***************
*** 302,320 ****
        /* If exported function, define it now.  Don't import functions from
  	 the environment in privileged mode. */
!       if (privmode == 0 && read_but_dont_execute == 0 && STREQN ("() {", string, 4))
  	{
  	  string_length = strlen (string);
! 	  temp_string = (char *)xmalloc (3 + string_length + char_index);
  
! 	  strcpy (temp_string, name);
! 	  temp_string[char_index] = ' ';
! 	  strcpy (temp_string + char_index + 1, string);
  
  	  /* Don't import function names that are invalid identifiers from the
  	     environment. */
! 	  if (legal_identifier (name))
! 	    parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
  
! 	  if (temp_var = find_function (name))
  	    {
  	      VSETATTR (temp_var, (att_exported|att_imported));
--- 307,336 ----
        /* If exported function, define it now.  Don't import functions from
  	 the environment in privileged mode. */
!       if (privmode == 0 && read_but_dont_execute == 0 &&
! 	  STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN) &&
! 	  STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN) &&
! 	  STREQN ("() {", string, 4))
  	{
+ 	  size_t namelen;
+ 	  char *tname;		/* desired imported function name */
+ 
+ 	  namelen = char_index - BASHFUNC_PREFLEN - BASHFUNC_SUFFLEN;
+ 
+ 	  tname = name + BASHFUNC_PREFLEN;	/* start of func name */
+ 	  tname[namelen] = '\0';		/* now tname == func name */
+ 
  	  string_length = strlen (string);
! 	  temp_string = (char *)xmalloc (namelen + string_length + 2);
  
! 	  memcpy (temp_string, tname, namelen);
! 	  temp_string[namelen] = ' ';
! 	  memcpy (temp_string + namelen + 1, string, string_length + 1);
  
  	  /* Don't import function names that are invalid identifiers from the
  	     environment. */
! 	  if (absolute_program (tname) == 0 && (posixly_correct == 0 || legal_identifier (tname)))
! 	    parse_and_execute (temp_string, tname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
  
! 	  if (temp_var = find_function (tname))
  	    {
  	      VSETATTR (temp_var, (att_exported|att_imported));
***************
*** 322,326 ****
  	    }
  	  else
! 	    report_error (_("error importing function definition for `%s'"), name);
  	}
  #if defined (ARRAY_VARS)
--- 338,345 ----
  	    }
  	  else
! 	    report_error (_("error importing function definition for `%s'"), tname);
! 
! 	  /* Restore original suffix */
! 	  tname[namelen] = BASHFUNC_SUFFIX[0];
  	}
  #if defined (ARRAY_VARS)
***************
*** 2215,2219 ****
  
    INVALIDATE_EXPORTSTR (var);
!   var->exportstr = mk_env_string (name, value);
  
    array_needs_making = 1;
--- 2234,2238 ----
  
    INVALIDATE_EXPORTSTR (var);
!   var->exportstr = mk_env_string (name, value, 0);
  
    array_needs_making = 1;
***************
*** 3003,3021 ****
  
  static inline char *
! mk_env_string (name, value)
       const char *name, *value;
  {
!   int name_len, value_len;
!   char	*p;
  
    name_len = strlen (name);
    value_len = STRLEN (value);
!   p = (char *)xmalloc (2 + name_len + value_len);
!   strcpy (p, name);
!   p[name_len] = '=';
    if (value && *value)
!     strcpy (p + name_len + 1, value);
    else
!     p[name_len + 1] = '\0';
    return (p);
  }
--- 3022,3061 ----
  
  static inline char *
! mk_env_string (name, value, isfunc)
       const char *name, *value;
+      int isfunc;
  {
!   size_t name_len, value_len;
!   char	*p, *q;
  
    name_len = strlen (name);
    value_len = STRLEN (value);
! 
!   /* If we are exporting a shell function, construct the encoded function
!      name. */
!   if (isfunc && value)
!     {
!       p = (char *)xmalloc (BASHFUNC_PREFLEN + name_len + BASHFUNC_SUFFLEN + value_len + 2);
!       q = p;
!       memcpy (q, BASHFUNC_PREFIX, BASHFUNC_PREFLEN);
!       q += BASHFUNC_PREFLEN;
!       memcpy (q, name, name_len);
!       q += name_len;
!       memcpy (q, BASHFUNC_SUFFIX, BASHFUNC_SUFFLEN);
!       q += BASHFUNC_SUFFLEN;
!     }
!   else
!     {
!       p = (char *)xmalloc (2 + name_len + value_len);
!       memcpy (p, name, name_len);
!       q = p + name_len;
!     }
! 
!   q[0] = '=';
    if (value && *value)
!     memcpy (q + 1, value, value_len + 1);
    else
!     q[1] = '\0';
! 
    return (p);
  }
***************
*** 3092,3096 ****
  	     using the cached exportstr... */
  	  list[list_index] = USE_EXPORTSTR ? savestring (value)
! 					   : mk_env_string (var->name, value);
  
  	  if (USE_EXPORTSTR == 0)
--- 3132,3136 ----
  	     using the cached exportstr... */
  	  list[list_index] = USE_EXPORTSTR ? savestring (value)
! 					   : mk_env_string (var->name, value, function_p (var));
  
  	  if (USE_EXPORTSTR == 0)
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 19
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 20
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-021

Bug-Reported-by:	Florian Weimer <fweimer@redhat.com>
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

There are two local buffer overflows in parse.y that can cause the shell
to dump core when given many here-documents attached to a single command
or many nested loops.

Patch:

*** ../bash-3.1.20/parse.y	2014-09-27 12:16:39.000000000 -0400
--- parse.y	2014-09-30 19:49:41.000000000 -0400
***************
*** 167,170 ****
--- 167,173 ----
  static int reserved_word_acceptable __P((int));
  static int yylex __P((void));
+ 
+ static void push_heredoc __P((REDIRECT *));
+ static char *mk_alexpansion __P((char *));
  static int alias_expand_token __P((char *));
  static int time_command_acceptable __P((void));
***************
*** 259,263 ****
  /* Variables to manage the task of reading here documents, because we need to
     defer the reading until after a complete command has been collected. */
! static REDIRECT *redir_stack[10];
  int need_here_doc;
  
--- 262,268 ----
  /* Variables to manage the task of reading here documents, because we need to
     defer the reading until after a complete command has been collected. */
! #define HEREDOC_MAX 16
! 
! static REDIRECT *redir_stack[HEREDOC_MAX];
  int need_here_doc;
  
***************
*** 285,289 ****
     index is decremented after a case, select, or for command is parsed. */
  #define MAX_CASE_NEST	128
! static int word_lineno[MAX_CASE_NEST];
  static int word_top = -1;
  
--- 290,294 ----
     index is decremented after a case, select, or for command is parsed. */
  #define MAX_CASE_NEST	128
! static int word_lineno[MAX_CASE_NEST+1];
  static int word_top = -1;
  
***************
*** 430,434 ****
  			  redir.filename = $2;
  			  $$ = make_redirection (0, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = $$;
  			}
  	|	NUMBER LESS_LESS WORD
--- 435,439 ----
  			  redir.filename = $2;
  			  $$ = make_redirection (0, r_reading_until, redir);
! 			  push_heredoc ($$);
  			}
  	|	NUMBER LESS_LESS WORD
***************
*** 436,440 ****
  			  redir.filename = $3;
  			  $$ = make_redirection ($1, r_reading_until, redir);
! 			  redir_stack[need_here_doc++] = $$;
  			}
  	|	LESS_LESS_LESS WORD
--- 441,445 ----
  			  redir.filename = $3;
  			  $$ = make_redirection ($1, r_reading_until, redir);
! 			  push_heredoc ($$);
  			}
  	|	LESS_LESS_LESS WORD
***************
*** 493,497 ****
  			  $$ = make_redirection
  			    (0, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = $$;
  			}
  	|	NUMBER LESS_LESS_MINUS WORD
--- 498,502 ----
  			  $$ = make_redirection
  			    (0, r_deblank_reading_until, redir);
! 			  push_heredoc ($$);
  			}
  	|	NUMBER LESS_LESS_MINUS WORD
***************
*** 500,504 ****
  			  $$ = make_redirection
  			    ($1, r_deblank_reading_until, redir);
! 			  redir_stack[need_here_doc++] = $$;
  			}
  	|	GREATER_AND '-'
--- 505,509 ----
  			  $$ = make_redirection
  			    ($1, r_deblank_reading_until, redir);
! 			  push_heredoc ($$);
  			}
  	|	GREATER_AND '-'
***************
*** 2211,2214 ****
--- 2216,2234 ----
  static int esacs_needed_count;
  
+ static void
+ push_heredoc (r)
+      REDIRECT *r;
+ {
+   if (need_here_doc >= HEREDOC_MAX)
+     {
+       last_command_exit_value = EX_BADUSAGE;
+       need_here_doc = 0;
+       report_syntax_error (_("maximum here-document count exceeded"));
+       reset_parser ();
+       exit_shell (last_command_exit_value);
+     }
+   redir_stack[need_here_doc++] = r;
+ }
+ 
  void
  gather_here_documents ()
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 20
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 21
  
  #endif /* _PATCHLEVEL_H_ */
			     BASH PATCH REPORT
			     =================

Bash-Release: 3.1
Patch-ID: bash31-022

Bug-Reported-by:	Michal Zalewski <lcamtuf@coredump.cx>
Bug-Reference-ID:
Bug-Reference-URL:

Bug-Description:

When bash is parsing a function definition that contains a here-document
delimited by end-of-file (or end-of-string), it leaves the closing delimiter
uninitialized.  This can result in an invalid memory access when the parsed
function is later copied.

Patch:

*** ../bash-3.1.21/make_cmd.c	2005-07-07 08:14:57.000000000 -0400
--- make_cmd.c	2014-10-02 20:33:47.000000000 -0400
***************
*** 672,675 ****
--- 672,676 ----
    temp->redirector = source;
    temp->redirectee = dest_and_filename;
+   temp->here_doc_eof = 0;
    temp->instruction = instruction;
    temp->flags = 0;
*** ../bash-3.1.21/copy_cmd.c	2003-10-07 11:43:44.000000000 -0400
--- copy_cmd.c	2014-10-02 20:33:47.000000000 -0400
***************
*** 117,121 ****
      case r_reading_until:
      case r_deblank_reading_until:
!       new_redirect->here_doc_eof = savestring (redirect->here_doc_eof);
        /*FALLTHROUGH*/
      case r_reading_string:
--- 117,121 ----
      case r_reading_until:
      case r_deblank_reading_until:
!       new_redirect->here_doc_eof = redirect->here_doc_eof ? savestring (redirect->here_doc_eof) : 0;
        /*FALLTHROUGH*/
      case r_reading_string:
*** ../bash-3.1/patchlevel.h	Wed Jul 20 13:58:20 2005
--- patchlevel.h	Wed Dec  7 13:48:42 2005
***************
*** 26,30 ****
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 21
  
  #endif /* _PATCHLEVEL_H_ */
--- 26,30 ----
     looks for to find the patch level (for the sccs version string). */
  
! #define PATCHLEVEL 22
  
  #endif /* _PATCHLEVEL_H_ */
EOF
