==> debug-trap.patch <==
*** ../bash-4.3/trap.c	2014-02-05 10:03:21.000000000 -0500
--- x/trap.c	2014-02-28 09:51:43.000000000 -0500
***************
*** 921,925 ****
  
  #if defined (JOB_CONTROL)
!       save_pipeline (1);	/* XXX only provides one save level */
  #endif
  
--- 921,926 ----
  
  #if defined (JOB_CONTROL)
!       if (sig != DEBUG_TRAP)	/* run_debug_trap does this */
! 	save_pipeline (1);	/* XXX only provides one save level */
  #endif
  
***************
*** 941,945 ****
  
  #if defined (JOB_CONTROL)
!       restore_pipeline (1);
  #endif
  
--- 942,947 ----
  
  #if defined (JOB_CONTROL)
!       if (sig != DEBUG_TRAP)	/* run_debug_trap does this */
! 	restore_pipeline (1);
  #endif
  

==> jobs-exit.patch <==
*** ../bash-4.3/jobs.c	2014-01-10 09:05:34.000000000 -0500
--- x/jobs.c	2014-03-02 18:05:09.000000000 -0500
***************
*** 4375,4379 ****
  end_job_control ()
  {
!   if (interactive_shell)		/* XXX - should it be interactive? */
      {
        terminate_stopped_jobs ();
--- 4375,4379 ----
  end_job_control ()
  {
!   if (interactive_shell || job_control)		/* XXX - should it be just job_control? */
      {
        terminate_stopped_jobs ();

==> test-nameref.patch <==
*** ../bash-4.3/test.c	2014-02-04 16:52:58.000000000 -0500
--- x/test.c	2014-02-28 21:22:44.000000000 -0500
***************
*** 647,652 ****
  
      case 'R':
!       v = find_variable (arg);
!       return (v && invisible_p (v) == 0 && var_isset (v) && nameref_p (v) ? TRUE : FALSE);
      }
  
--- 647,652 ----
  
      case 'R':
!       v = find_variable_noref (arg);
!       return ((v && invisible_p (v) == 0 && var_isset (v) && nameref_p (v)) ? TRUE : FALSE);
      }
  
***************
*** 724,727 ****
--- 724,728 ----
      case 'u': case 'v': case 'w': case 'x': case 'z':
      case 'G': case 'L': case 'O': case 'S': case 'N':
+     case 'R':
        return (1);
      }

==> pcomplete-dequote.patch <==
*** ../bash-4.3/pcomplete.c	2013-08-26 15:23:45.000000000 -0400
--- x/pcomplete.c	2014-03-07 13:12:42.000000000 -0500
***************
*** 184,187 ****
--- 184,188 ----
  COMPSPEC *pcomp_curcs;
  const char *pcomp_curcmd;
+ const char *pcomp_curtxt;
  
  #ifdef DEBUG
***************
*** 754,757 ****
--- 755,767 ----
  	  dfn = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
  	}
+       /* Intended to solve a mismatched assumption by bash-completion.  If
+ 	 the text to be completed is empty, but bash-completion turns it into
+ 	 a quoted string ('') assuming that this code will dequote it before
+ 	 calling readline, do the dequoting. */
+       else if (iscompgen && iscompleting &&
+ 	       pcomp_curtxt && *pcomp_curtxt == 0 &&
+ 	       text && (*text == '\'' || *text == '"') && text[1] == text[0] && text[2] == 0 && 
+ 	       rl_filename_dequoting_function)
+ 	  dfn = (*rl_filename_dequoting_function) ((char *)text, rl_completion_quote_character);
        else
  	dfn = savestring (text);
***************
*** 1523,1527 ****
  {
    COMPSPEC *cs, *oldcs;
!   const char *oldcmd;
    STRINGLIST *ret;
  
--- 1533,1537 ----
  {
    COMPSPEC *cs, *oldcs;
!   const char *oldcmd, *oldtxt;
    STRINGLIST *ret;
  
***************
*** 1546,1552 ****
--- 1556,1564 ----
    oldcs = pcomp_curcs;
    oldcmd = pcomp_curcmd;
+   oldtxt = pcomp_curtxt;
  
    pcomp_curcs = cs;
    pcomp_curcmd = cmd;
+   pcomp_curtxt = word;
  
    ret = gen_compspec_completions (cs, cmd, word, start, end, foundp);
***************
*** 1554,1557 ****
--- 1566,1570 ----
    pcomp_curcs = oldcs;
    pcomp_curcmd = oldcmd;
+   pcomp_curtxt = oldtxt;
  
    /* We need to conditionally handle setting *retryp here */

==> parse-ansi-expand.patch <==
*** ../bash-4.3/parse.y	2014-02-11 09:42:10.000000000 -0500
--- x/parse.y	2014-03-07 20:57:15.000000000 -0500
***************
*** 3399,3403 ****
           unescaped double-quotes or single-quotes, if any, shall occur." */
        /* This was changed in Austin Group Interp 221 */
!       if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
  	continue;
  
--- 3399,3403 ----
           unescaped double-quotes or single-quotes, if any, shall occur." */
        /* This was changed in Austin Group Interp 221 */
!       if MBTEST(posixly_correct && shell_compatibility_level > 41 && dolbrace_state != DOLBRACE_QUOTE && dolbrace_state != DOLBRACE_QUOTE2 && (flags & P_DQUOTE) && (flags & P_DOLBRACE) && ch == '\'')
  	continue;
  
==> compound-array-empty-value.patch <==
*** ../bash-4.3/arrayfunc.c	2013-08-02 16:19:59.000000000 -0400
--- x/arrayfunc.c	2014-03-18 11:08:15.000000000 -0400
***************
*** 598,601 ****
--- 598,606 ----
  	{
  	  val = expand_assignment_string_to_string (val, 0);
+ 	  if (val == 0)
+ 	    {
+ 	      val = (char *)xmalloc (1);
+ 	      val[0] = '\0';	/* like do_assignment_internal */
+ 	    }
  	  free_val = 1;
  	}
